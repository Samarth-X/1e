<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mirror Maze</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-family: sans-serif;
    }
    h1 { margin: 10px; font-size: 1.4em; }
    .canvases {
      display: flex;
      gap: 10px;
      margin: 10px;
    }
    canvas {
      background: #111;
      border: 2px solid #555;
    }
    .controls {
      display: grid;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      grid-gap: 5px;
      margin: 10px;
    }
    .controls button {
      border: none;
      border-radius: 8px;
      background: #444;
      color: #fff;
      font-size: 1.5rem;
      touch-action: manipulation;
    }
    #up    { grid-area: up;    }
    #down  { grid-area: down;  }
    #left  { grid-area: left;  }
    #right { grid-area: right; }
    .action {
      margin: 10px;
      padding: 10px 20px;
      font-size: 1rem;
      border-radius: 4px;
      background: #444;
      color: #fff;
    }
    #message { margin: 5px; text-align: center; }

    @media (max-width: 600px) {
      .canvases { flex-direction: column; gap: 5px; }
      .controls button { width: 50px; height: 50px; font-size: 1.2rem; }
      .action { font-size: 0.9rem; padding: 8px 16px; }
    }
  </style>
</head>
<body>
  <h1>Mirror Maze - Level <span id="level">1</span></h1>
  <div class="canvases">
    <canvas id="maze1"></canvas>
    <canvas id="maze2"></canvas>
  </div>
  <div class="controls">
    <button id="up">▲</button>
    <button id="left">◀</button>
    <button id="right">▶</button>
    <button id="down">▼</button>
  </div>
  <div>
    <button id="nextBtn" class="action" style="display:none;">Next Level</button>
    <button id="restartBtn" class="action" style="display:none;">Restart</button>
  </div>
  <div id="message">Use arrows or swipe to move.</div>

  <script>
    let currentLevel = 1;
    const maxLevels = 20;
    let gridSize = 15;
    let maze, player, exitPos;
    let cellSize;

    function shuffle(a) {
      for (let i = a.length-1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
    }

    function generateMaze(n) {
      const m = Array.from({length:n}, () => Array(n).fill(1));
      function carve(x,y) {
        m[y][x] = 0;
        const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
        shuffle(dirs);
        dirs.forEach(([dx,dy]) => {
          const nx = x+dx, ny = y+dy;
          if (ny>0 && ny<n-1 && nx>0 && nx<n-1 && m[ny][nx]) {
            m[y+dy/2][x+dx/2] = 0;
            carve(nx,ny);
          }
        });
      }
      carve(1,1);
      return m;
    }

    function initLayout() {
      const availableWidth = window.innerWidth - 20;
      const availableHeight = window.innerHeight - 120;
      const cols = (availableWidth > availableHeight)
        ? gridSize * 2 + 1
        : gridSize;
      cellSize = Math.floor(Math.min(availableWidth/cols, availableHeight/gridSize));

      const canvases = document.querySelector('.canvases');
      canvases.style.flexDirection = (availableWidth > availableHeight) ? 'row' : 'column';

      ["maze1","maze2"].forEach(id => {
        const c = document.getElementById(id);
        c.width = gridSize * cellSize;
        c.height = gridSize * cellSize;
      });
    }

    function startLevel() {
      maze = generateMaze(gridSize);
      player = {x:1,y:1};
      exitPos = {x:gridSize-2, y:gridSize-2};
      document.getElementById('level').textContent = currentLevel;
      document.getElementById('nextBtn').style.display = 'none';
      document.getElementById('restartBtn').style.display = 'none';
      document.getElementById('message').textContent = 'Use arrows or swipe to move.';
      initLayout();
      render();
    }

    function drawMaze(ctx, mirror=false) {
      maze.forEach((row,y) => row.forEach((cell,x) => {
        const dx = mirror ? gridSize-1-x : x;
        ctx.fillStyle = cell ? '#555' : '#222';
        ctx.fillRect(dx*cellSize, y*cellSize, cellSize, cellSize);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(dx*cellSize, y*cellSize, cellSize, cellSize);
      }));
    }

    function render() {
      if (!player) return;
      const [ctx1,ctx2] = ["maze1","maze2"].map(id => document.getElementById(id).getContext('2d'));
      ctx1.clearRect(0,0,gridSize*cellSize,gridSize*cellSize);
      ctx2.clearRect(0,0,gridSize*cellSize,gridSize*cellSize);
      drawMaze(ctx1);
      drawMaze(ctx2,true);
      const mx = gridSize-1-player.x;
      [ctx1,ctx2].forEach(ctx => ctx.fillStyle='#0f0');
      ctx1.fillRect(player.x*cellSize+4,player.y*cellSize+4,cellSize-8,cellSize-8);
      ctx2.fillRect(mx*cellSize+4,player.y*cellSize+4,cellSize-8,cellSize-8);
    }

    function tryMove(dx,dy) {
      if (!player) return;
      const nx=player.x+dx, ny=player.y+dy;
      const mx = gridSize-1-nx;
      if (ny>=0 && ny<gridSize && nx>=0 && nx<gridSize
          && !maze[ny][nx] && !maze[ny][mx]) {
        player={x:nx,y:ny};
        render();
        if (nx===exitPos.x && ny===exitPos.y) winLevel();
      }
    }

    function winLevel() {
      const msg = document.getElementById('message');
      if (currentLevel<maxLevels) {
        msg.textContent = `Level ${currentLevel} complete! Tap Next.`;
        document.getElementById('nextBtn').style.display='inline-block';
      } else {
        msg.textContent='All levels done!';
        document.getElementById('restartBtn').style.display='inline-block';
      }
    }

    ['up','down','left','right'].forEach((dir, i) => {
      const [dx,dy] = [[0,-1],[0,1],[-1,0],[1,0]][i];
      const btn = document.getElementById(dir);
      btn.addEventListener('touchstart', e=>{e.preventDefault(); tryMove(dx,dy);}, {passive:false});
      btn.addEventListener('mousedown', e=>{e.preventDefault(); tryMove(dx,dy);});
    });
    document.getElementById('nextBtn').addEventListener('click', ()=>{ currentLevel++; startLevel(); });
    document.getElementById('restartBtn').addEventListener('click', ()=>{ currentLevel=1; startLevel(); });
    window.addEventListener('keydown', e=>{
      const map={ArrowUp:[0,-1],ArrowDown:[0,1],ArrowLeft:[-1,0],ArrowRight:[1,0]};
      if(map[e.key]){ e.preventDefault(); tryMove(...map[e.key]); }
    });

    let sx,sy;
    document.addEventListener('touchstart', e=>{sx=e.touches[0].clientX; sy=e.touches[0].clientY;}, {passive:true});
    document.addEventListener('touchend', e=>{const ex=e.changedTouches[0].clientX, ey=e.changedTouches[0].clientY;
      const dx=ex-sx, dy=ey-sy;
      if(Math.abs(dx)>Math.abs(dy)){ dx>30?tryMove(1,0):dx<-30&&tryMove(-1,0);
      } else { dy>30?tryMove(0,1):dy<-30&&tryMove(0,-1); }
    }, {passive:true});

    window.addEventListener('resize', ()=>{ initLayout(); render(); });
    window.addEventListener('load', startLevel);
  </script>
</body>
</html>
