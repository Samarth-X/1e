<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Orbit Simulator</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
    }
    .game-container {
      width: 100vw;
      height: 60vh;
      max-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    canvas { display: block; width: 100%; height: 100%; }
    #controls { margin-top: 10px; }
    button.action {
      padding: 8px 16px;
      margin: 0 5px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background: #444;
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <canvas id="orbitCanvas"></canvas>
  </div>
  <div id="controls">
    <button id="nextGalaxyBtn" class="action">Next Galaxy</button>
  </div>

  <script>
    const canvas = document.getElementById('orbitCanvas');
    const ctx = canvas.getContext('2d');
    let width, height, cx, cy;

    // Define fixed orbits
    const orbitDs = [0.2, 0.3, 0.4, 0.5, 0.7, 0.85];
    // Base planet templates
    const basePlanets = [
      { name: 'Mercury', r: 4, color: '#aaa', period: 4.8 },
      { name: 'Venus',   r: 6, color: '#e5c07b', period: 12.1 },
      { name: 'Earth',   r: 6, color: '#61afef', period: 15 },
      { name: 'Mars',    r: 5, color: '#e06c75', period: 28.3 },
      { name: 'Jupiter', r: 10, color: '#d19a66', period: 200 },
      { name: 'Saturn',  r: 9, color: '#c678dd', period: 500 }
    ];
    // Galaxies: different shuffles of basePlanets
    const galaxies = [];
    function shuffleArr(a) { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} }
    // Precompute 5 galaxy configs
    for(let g=0; g<5; g++){
      const arr = basePlanets.map(p=>({ ...p }));
      if(g>0) shuffleArr(arr);
      galaxies.push(arr);
    }
    let galaxyIndex = 0;
    let planets = galaxies[galaxyIndex].map((p,i)=>({ ...p, d: orbitDs[i] }));

    function resize() {
      width = canvas.clientWidth * devicePixelRatio;
      height = canvas.clientHeight * devicePixelRatio;
      canvas.width = width;
      canvas.height = height;
      cx = width/2; cy = height/2;
    }
    window.addEventListener('resize', resize);
    resize();

    let start = performance.now();

    // Drag state
    let drag = { index: null, x:0, y:0 };
    canvas.addEventListener('pointerdown', e=>{
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left)*devicePixelRatio;
      const my = (e.clientY - rect.top)*devicePixelRatio;
      planets.forEach((p,i)=>{
        const orbitR = Math.min(cx,cy)*p.d;
        const t = (performance.now()-start)/1000;
        const angle = (t/p.period)*2*Math.PI;
        const px = cx + Math.cos(angle)*orbitR;
        const py = cy + Math.sin(angle)*orbitR;
        if(Math.hypot(px-mx,py-my) < p.r*devicePixelRatio) {
          drag.index = i;
          drag.x = mx; drag.y = my;
        }
      });
    });
    canvas.addEventListener('pointermove', e=>{
      if(drag.index===null) return;
      const rect = canvas.getBoundingClientRect();
      drag.x = (e.clientX-rect.left)*devicePixelRatio;
      drag.y = (e.clientY-rect.top)*devicePixelRatio;
    });
    canvas.addEventListener('pointerup', e=>{
      if(drag.index===null) return;
      // Determine nearest orbit
      const dist = Math.hypot(drag.x-cx, drag.y-cy);
      let best = 0, bd = Infinity;
      orbitDs.forEach((d,i)=>{
        const rd = Math.abs(dist - Math.min(cx,cy)*d);
        if(rd < bd){ bd = rd; best = i; }
      });
      // swap if different
      if(best !== drag.index) {
        [planets[best], planets[drag.index]] = [planets[drag.index], planets[best]];
      }
      drag.index = null;
    });

    function draw() {
      const t = (performance.now()-start)/1000;
      ctx.clearRect(0,0,width,height);
      // Sun
      ctx.beginPath(); ctx.arc(cx,cy,20*devicePixelRatio,0,2*Math.PI);
      const grad = ctx.createRadialGradient(cx,cy,5*devicePixelRatio,cx,cy,20*devicePixelRatio);
      grad.addColorStop(0,'#fff200');grad.addColorStop(1,'#ff9800');
      ctx.fillStyle=grad;ctx.fill();

      planets.forEach((p,i)=>{
        const orbitR = Math.min(cx,cy)*p.d;
        // orbit
        ctx.beginPath(); ctx.arc(cx,cy,orbitR,0,2*Math.PI);
        ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=1;ctx.stroke();
        // position
        let px,py;
        if(i===drag.index) {
          px = drag.x; py = drag.y;
        } else {
          const angle=(t/p.period)*2*Math.PI;
          px=cx+Math.cos(angle)*orbitR;
          py=cy+Math.sin(angle)*orbitR;
        }
        ctx.beginPath(); ctx.fillStyle=p.color;
        ctx.arc(px,py,p.r*devicePixelRatio,0,2*Math.PI); ctx.fill();
      });

      requestAnimationFrame(draw);
    }
    draw();

    // Next Galaxy
    document.getElementById('nextGalaxyBtn').addEventListener('click', ()=>{
      const choice = prompt('Enter next galaxy number (1-5):');
      const idx = parseInt(choice) - 1;
      if(idx>=0 && idx<galaxies.length) {
        galaxyIndex = idx;
        planets = galaxies[galaxyIndex].map((p,i)=>({ ...p, d: orbitDs[i] }));
        start = performance.now();
      }
    });
  </script>
</body>
</html>
